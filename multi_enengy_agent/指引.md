下面是我基于你给的《详细想法.md》里“多智能体层（从选区到报告的流水线）+共享黑板字段”这部分要求，给出的 **LangGraph + OpenAI** 的多智能体层核心设计与最小可运行流水线方案（含：各 Agent 输入/输出 Schema、任务边界、人工校验点、最小可运行编排、以及中间结果样例）。 

---

## 1) 设计目标与关键原则（多智能体层只做“中间环节”）

你们导师要求的多智能体层，本质是把“从选区→基线→措施筛选→经济性→报告”的计算链，拆成可审计、可复算、可落库的中间结果。你文件里也强调了每个 Agent 输出结构化结果，并带 `evidence + assumptions + reproducibility` 来保证审计与复算。

我建议遵循 4 个硬原则：

1) **LLM 不直接产出关键数值**  
   - 关键数值（能耗、减排、NPV/IRR/MAC）必须来自 **确定性函数/模型**（可版本化）。  
   - LLM 只做：分类、摘要、规则匹配、解释文字、补数清单生成、置信度/风险描述。

2) **统一“共享黑板（Blackboard State）”与“结果信封（Result Envelope）”**  
   - 每个阶段都输出一个 `ResultEnvelope`，字段对齐你文件中建议的结构：  
     `result_id/scenario_id/region_id/metrics/assumptions/evidence/confidence/data_gaps/reproducibility`。

3) **人工校验点是“流水线的一等公民”**  
   - 每个 Agent 都必须声明：  
     - 什么情况下要人工确认（触发条件）  
     - 人工能改哪些字段（可编辑范围）  
     - 人工确认后如何落库（审计记录）

4) **最小可运行（MVP）先做“闭环”，再做“最优”**  
   - MVP 先跑通：**选区 → 基线（能耗+S1/S2）→ 措施筛选 → 经济性（简化现金流）→ 报告（Markdown/HTML）**  
   - 复杂优化（MILP、8760仿真、CCU网络）先占位，后续替换即可。

---

## 2) 统一 Schema：共享黑板 State + 每段 ResultEnvelope

### 2.1 ResultEnvelope（强制落库与追溯）
这是你文件里“任何数字都应能通过 evidence + assumptions + reproducibility 复算与审计”的落地实现。

**ResultEnvelope（建议）**
- `result_id / scenario_id / region_id`
- `stage`：`geo | baseline | measures | finance | report`
- `metrics`：阶段产出的结构化指标（允许嵌套）
- `artifacts`：大对象（企业清单、曲线、候选措施表、报告章节等）
- `assumptions[]`：每条假设可追溯（名称/值/单位/理由/敏感性）
- `evidence[]`：证据引用（doc/table/api/file）、id、时间戳、版本
- `confidence`：建议数值 0~1（也可映射 A/B/C）
- `data_gaps[]`：缺口字段 + 影响指标/报告章节
- `reproducibility`：`model_version/param_version/solver_version/code_commit`

> 说明：**MVP 阶段先把 `model_version/param_version` 做出来**，后面再把 solver、commit、容器镜像 digest 加进去。

### 2.2 BlackboardState（LangGraph 的 State）
State 用于在 LangGraph 节点间传递，典型字段：

- `job_id`
- `scenario`（价格、WACC、折现率、口径版本等）
- `selection`（polygon/行政区/园区id）
- `envelopes`：`{stage -> ResultEnvelope}`
- `review_queue`：待人工校验项（每项含：问题、建议动作、可编辑字段）
- `logs`：每个节点的运行摘要（输入 hash、输出 hash、耗时、异常）

---

## 3) 最小可运行流水线（MVP）与 Agent 划分

你文件中列了完整的 Agent 列表（Geo Resolver、Baseline Synthesizer、GHG Accountant、Measure Screener、Finance Integrator、Report Orchestrator…）。MVP 我建议合并一些环节，先保证闭环可跑。

### MVP 5 段链路（从选区→报告）

1) **GeoResolverAgent（选区解析）**  
2) **BaselineAgent（基线：能耗+S1/S2，先合并 Synthesizer + Accountant）**  
3) **MeasureScreenerAgent（措施筛选）**  
4) **FinanceIntegratorAgent（经济性）**  
5) **ReportOrchestratorAgent（报告编排）**

> 后续扩展：再把 Baseline 拆成 Synthesizer/Accountant，把政策与合规（RAG）插入到 Measures/Report 之间。

---

## 4) 各 Agent 的输入/输出 Schema、任务边界、人工校验点（可直接写进代码注释/README）

下面每个 Agent 我都写成“可工程落地”的形式：Input/Output + 边界 + 人工校验点。

---

### 4.1 GeoResolverAgent（选区 → 园区画像骨架/数据完备度）

**Input Schema（GeoResolverInput）**
- `selection`
  - `type`: `polygon | admin_code | park_id`
  - `geometry`（polygon 坐标/行政区编码/园区ID）
- `scenario_context`（可选：用于选择电价/排放因子地域版本）
- `available_layers`（数据层告诉它当前可用的数据集与版本号）

**Output Schema（ResultEnvelope stage=geo）**
- `metrics`
  - `area_km2`
  - `admin_codes`（省/市/区县/街道）
  - `entity_count_est`（企业数量估计）
  - `data_completeness_score`（0~1）
- `artifacts`
  - `region_boundary`（GeoJSON）
  - `entities_raw[]`（候选企业/设施点，带来源与置信度）
  - `layer_clip_manifest[]`（裁剪了哪些图层、裁剪参数）
- `data_gaps[]`
  - 缺：企业名录/行业代码/电价规则/排放因子版本 等

**任务边界**
- ✅ 做：空间裁剪、行政区匹配、基础画像统计、数据可用性盘点（数据完备度）。  
- ❌ 不做：任何能耗/排放/经济性推导（避免“早算错”污染后续）。

**人工校验点（Human Checkpoint）**
- 触发条件：
  - polygon 自交/面积异常
  - 行政区匹配置信度低（例如多区交叠）
  - 企业数量与预期偏差过大（>2x）
- 人工可改字段：
  - `region_boundary`（确认选区）
  - `admin_codes`（确认归属）
  - `entities_raw` 的删改（删掉明显不属于园区的 POI）

---

### 4.2 BaselineAgent（园区画像 → 基线能耗/负荷 + S1/S2）

**Input Schema（BaselineInput）**
- `geo_envelope.artifacts.region_boundary`
- `geo_envelope.artifacts.entities_raw`
- `kpi_spec_ref`（指标层输出：S1/S2 边界、单位、时间/空间粒度、排放因子版本）← 强依赖指标层  
- `metering_data`（可选：有真实计量就用；没有就用 proxy）
- `emission_factors`（版本化：电网、燃料；缺则写 data_gaps）

**Output Schema（ResultEnvelope stage=baseline）**
- `metrics`（示例）
  - `baseline_electricity_kwh_y`
  - `baseline_gas_nm3_y`
  - `baseline_steam_t_y`（如有）
  - `S1_tco2e_y`
  - `S2_tco2e_y`
  - `total_tco2e_y`
  - `uncertainty_pct`（关键：区间/置信）
- `artifacts`
  - `energy_balance`（结构化能流表）
  - `baseline_method`（方法声明：计量/统计/估算/proxy）
  - `top_emitters[]`（主要贡献来源）
- `assumptions[]`
  - proxy 规则（如：按建筑面积估电耗、按行业模板估燃气等）
- `evidence[]`
  - 用到的计量数据/统计年鉴/企业年报摘要/排放因子文档 id
- `data_gaps[]`
  - 缺：企业行业细分、热/蒸汽曲线、燃料热值、机组效率等

**任务边界**
- ✅ 做：基线核算（S1/S2）、贡献拆分、口径声明、不确定性。  
- ❌ 不做：措施组合优化/财务测算（避免在基线上叠加方案假设）。

**人工校验点**
- 触发条件：
  - proxy 占比高（>50% 能耗来自估算）
  - 排放因子版本缺失或不确定
  - 不确定性 > 30%
- 人工可改字段：
  - 关键假设（例如：开工率、单位产能能耗区间、排放因子版本）
  - “重点企业/重点排放源”识别结果

---

### 4.3 MeasureScreenerAgent（基线 → 候选措施清单）

**Input Schema（MeasureScreenerInput）**
- `baseline_envelope.metrics + artifacts`
- `geo_envelope.artifacts.entities_raw`（行业结构/空间约束）
- `measure_library`（技术措施库：适用条件/寿命/CAPEX/OPEX/性能曲线等）
- `constraints`（电网/气网接入裕度、土地/建筑可用面积等；缺则 data_gaps）

**Output Schema（ResultEnvelope stage=measures）**
- `metrics`
  - `candidate_count`
  - `avg_applicability_score`
- `artifacts`
  - `candidates[]`（每项含：适用性评分、依赖数据、预期影响范围、风险点）
  - `required_data_for_top10[]`（Top 措施的补数清单）
- `assumptions[]`
  - “缺数据时的默认阈值/保守参数”
- `data_gaps[]`
  - 缺：屋顶可用面积、蒸汽压力等级、余热品位分布等

**任务边界**
- ✅ 做：筛选、排序、补数项定位（“要算这个措施还缺什么数据”）。  
- ❌ 不做：组合最优解（这属于 Energy System Planner/优化层，MVP 先不做）。

**人工校验点**
- 触发条件：
  - Top 措施明显不符合现场常识（比如无屋顶却推荐光伏）
  - 关键约束缺失导致评分失真
- 人工可改字段：
  - `candidates` 的启用/禁用
  - 适用性评分的权重（策略参数）

---

### 4.4 FinanceIntegratorAgent（候选措施 → 经济性/投融资指标）

**Input Schema（FinanceInput）**
- `scenario_params`（电价/气价/碳价/WACC/税率/折旧/补贴等）
- `measures_envelope.artifacts.candidates`
- `baseline_envelope.metrics`
- `price_cost_library`（造价指数、设备成本、运维系数等）

**Output Schema（ResultEnvelope stage=finance）**
- `metrics`
  - `portfolio_capex`
  - `portfolio_opex_y`
  - `portfolio_npv`
  - `portfolio_irr`
  - `portfolio_payback_y`
  - `portfolio_mac_y_per_tco2`
- `artifacts`
  - `measure_cashflows[]`（每项现金流、NPV/IRR、敏感性）
  - `portfolio_selected[]`（MVP 可先按规则选 Top3）
  - `sensitivity`（电价/气价/碳价/WACC）
- `assumptions[]`
  - 贴现率、融资结构、补贴处理方式等
- `data_gaps[]`
  - 缺：税率、折旧年限、并网限制等

**任务边界**
- ✅ 做：现金流、NPV/IRR/回收期、MACC 输入表。  
- ❌ 不做：政策合规结论/条款引用（由 Policy&Compliance/RAG 做）。

**人工校验点**
- 触发条件：
  - IRR/回收期异常（比如负 CAPEX 或超高收益）
  - 关键价格缺失或采用默认值
- 人工可改字段：
  - 价格、WACC、补贴、寿命、CAPEX 乘数等参数

---

### 4.5 ReportOrchestratorAgent（结果 → 报告 Markdown/HTML + 附录）

你的文件里建议固定报告 12 个模块（执行摘要、数据说明、画像、基线、资源、机会清单、经济性、风险等），MVP 可以只填核心 6 个章节，其余留模板占位。

**Input Schema（ReportInput）**
- `geo_envelope + baseline_envelope + measures_envelope + finance_envelope`
- `report_template`（政府版/技术版/投资版）
- `policy_evidence`（可选：分析层产出的政策条款引用编号与证据）

**Output Schema（ResultEnvelope stage=report）**
- `metrics`
  - `report_pages_est`
- `artifacts`
  - `report_markdown`
  - `report_html`（可选）
  - `appendix_params_table`
  - `appendix_citations`
  - `result_table_for_ui`（前端展示用）
- `evidence[]`
  - 引用的文档/数据表/接口快照

**任务边界**
- ✅ 做：把“结构化结果”写进报告模板；生成引用清单与参数表。  
- ❌ 不做：再计算/再推导新数字（避免报告阶段“改数”）。

**人工校验点**
- 触发条件：
  - 结论置信度 < 0.6
  - data_gaps 影响到执行摘要/关键结论
- 人工可改字段：
  - 文案措辞、结论排序、风险提示强度（但不改数）

---

## 5) LangGraph 编排：最小可运行图（含人工校验路由）

### 5.1 节点与边（MVP）
```
START
  → geo_resolver
  → (if needs_review) human_review_geo → geo_resolver_finalize
  → baseline
  → (if needs_review) human_review_baseline → baseline_finalize
  → measure_screener
  → (if needs_review) human_review_measures → measure_finalize
  → finance
  → (if needs_review) human_review_finance → finance_finalize
  → report
END
```

### 5.2 “needs_review” 的规则（建议先用硬规则）
- `confidence < 0.7` 或 `uncertainty_pct > 0.3`
- 或 `data_gaps` 命中关键清单（例如排放因子版本、电价规则、园区边界不确定）

> 这样就能做到：流水线 **可自动跑通**，但会在低置信时把人工任务排入队列（下周 demo 也好讲）。

---

## 6) 核心代码骨架（OpenAI + LangGraph，可直接开仓）

下面代码是 **“能跑通的骨架”**：  
- 有统一 Schema  
- 有 LangGraph 编排  
- 有 review_queue（先不做真实交互，先把审计点产出来）  
- LLM 可选（你可以先 `USE_LLM=False` 用规则跑通 demo，再接 OpenAI）

> 你落地时建议拆成 `schemas.py / agents/*.py / graph.py / run.py`，我这里为了阅读合并在一段。

```python
# -*- coding: utf-8 -*-
from __future__ import annotations

from typing import Any, Dict, List, Literal, Optional, TypedDict
from dataclasses import dataclass
from datetime import datetime
import uuid
import math

from pydantic import BaseModel, Field

# ====== 1) 通用审计字段（对齐你们“共享黑板”建议） ======

class EvidenceItem(BaseModel):
    type: Literal["doc", "table", "api", "file"]
    id: str
    ts: str
    version: Optional[str] = None
    note: Optional[str] = None

class AssumptionItem(BaseModel):
    name: str
    value: Any
    unit: Optional[str] = None
    rationale: Optional[str] = None
    sensitivity: Optional[str] = None  # e.g. "high/medium/low"

class DataGap(BaseModel):
    missing: str
    impact: str  # which KPIs/sections
    severity: Literal["low", "medium", "high"] = "medium"
    workaround: Optional[str] = None

class Reproducibility(BaseModel):
    model_version: str
    param_version: str
    solver_version: Optional[str] = None
    code_commit: Optional[str] = None

class HumanCheckpoint(BaseModel):
    checkpoint: str
    question: str
    status: Literal["pending", "approved", "rejected"] = "pending"
    editable_fields: List[str] = Field(default_factory=list)
    trigger_reason: Optional[str] = None

class ResultEnvelope(BaseModel):
    result_id: str
    scenario_id: str
    region_id: str
    stage: Literal["geo", "baseline", "measures", "finance", "report"]
    metrics: Dict[str, Any] = Field(default_factory=dict)
    artifacts: Dict[str, Any] = Field(default_factory=dict)
    assumptions: List[AssumptionItem] = Field(default_factory=list)
    evidence: List[EvidenceItem] = Field(default_factory=list)
    confidence: float = 0.0
    data_gaps: List[DataGap] = Field(default_factory=list)
    reproducibility: Reproducibility
    human_checkpoints: List[HumanCheckpoint] = Field(default_factory=list)

# ====== 2) 业务输入 ======

class GeoSelection(BaseModel):
    type: Literal["polygon", "admin_code", "park_id"]
    geometry: Any  # GeoJSON polygon or str code
    name_hint: Optional[str] = None

class ScenarioParams(BaseModel):
    # MVP 先放关键的；后面扩展税率/折旧/补贴等
    electricity_price_y_per_kwh: float = 0.75
    gas_price_y_per_nm3: float = 2.8
    carbon_price_y_per_tco2: float = 80.0
    wacc: float = 0.08
    horizon_years: int = 15

    # 口径版本（指标层给）
    ghg_boundary: Literal["S1S2"] = "S1S2"
    grid_ef_version: str = "CN-grid-2024-v1"
    fuel_ef_version: str = "IPCC-2006-default-v1"

# ====== 3) LangGraph State（共享黑板） ======

class BlackboardState(TypedDict, total=False):
    job_id: str
    scenario_id: str
    region_id: str

    selection: GeoSelection
    scenario: ScenarioParams

    envelopes: Dict[str, Dict[str, Any]]  # stage -> envelope.model_dump()
    review_queue: List[Dict[str, Any]]
    logs: List[Dict[str, Any]]

# ====== 4) 工具/模型占位：数值计算一定要可复算 ======

def now_ts() -> str:
    return datetime.utcnow().isoformat() + "Z"

def new_id() -> str:
    return str(uuid.uuid4())

def calc_confidence(data_completeness: float, proxy_ratio: float) -> float:
    # 一个非常简单的启发式：完备度越高越好，proxy 越多越差
    return max(0.0, min(1.0, 0.2 + 0.8 * data_completeness - 0.5 * proxy_ratio))

def npv(discount: float, cashflows: List[float]) -> float:
    return sum(cf / ((1 + discount) ** t) for t, cf in enumerate(cashflows))

def simple_payback(capex: float, annual_net: float) -> Optional[float]:
    if annual_net <= 0:
        return None
    return capex / annual_net

# ====== 5) Agent 实现（MVP：规则 + 可选 LLM） ======

def geo_resolver_agent(state: BlackboardState) -> BlackboardState:
    job_id = state["job_id"]
    region_id = state["region_id"]
    scenario_id = state["scenario_id"]

    sel = state["selection"]

    # MVP：这里用 stub；真实实现应调用 PostGIS/瓦片/POI/工商等
    # 输出：boundary/admin_codes/entities_raw/data_completeness
    entities_raw = [
        {"name": "A化工", "lat": 30.1, "lon": 120.1, "industry_code": "C26", "source": "poi", "confidence": 0.7},
        {"name": "B材料", "lat": 30.11, "lon": 120.09, "industry_code": "C30", "source": "poi", "confidence": 0.6},
        {"name": "C制造", "lat": 30.12, "lon": 120.13, "industry_code": None, "source": "poi", "confidence": 0.5},
    ]
    data_completeness = 0.55  # stub

    env = ResultEnvelope(
        result_id=new_id(),
        scenario_id=scenario_id,
        region_id=region_id,
        stage="geo",
        metrics={
            "area_km2": 3.4,
            "admin_codes": {"province": "XX", "city": "YY", "district": "ZZ"},
            "entity_count_est": len(entities_raw),
            "data_completeness_score": data_completeness,
        },
        artifacts={
            "region_boundary": sel.geometry,
            "entities_raw": entities_raw,
            "layer_clip_manifest": [{"layer": "poi", "version": "2025-12", "method": "clip"}],
        },
        assumptions=[],
        evidence=[EvidenceItem(type="api", id="poi.search@2025-12", ts=now_ts(), version="v2").model_dump()],
        confidence=calc_confidence(data_completeness=data_completeness, proxy_ratio=0.2),
        data_gaps=[
            DataGap(missing="园区名录/企业统一社会信用代码", impact="企业去重、行业细分、产能proxy", severity="medium").model_dump(),
            DataGap(missing="园区电价规则/分时", impact="经济性、电力措施收益", severity="high").model_dump(),
        ],
        reproducibility=Reproducibility(model_version="geo@0.1.0", param_version="geo_params@0.1.0").model_dump(),
        human_checkpoints=[],
    )

    # 人工校验点：选区/行政区/企业数量异常
    if env.confidence < 0.7:
        env.human_checkpoints.append(
            HumanCheckpoint(
                checkpoint="geo.review",
                question="请确认选区边界/行政区归属/企业清单是否正确；如不正确请编辑 region_boundary 或 entities_raw。",
                editable_fields=["artifacts.region_boundary", "artifacts.entities_raw", "metrics.admin_codes"],
                trigger_reason=f"confidence={env.confidence:.2f} < 0.70",
            ).model_dump()
        )

    state.setdefault("envelopes", {})
    state["envelopes"]["geo"] = env.model_dump()
    state.setdefault("logs", []).append({"ts": now_ts(), "node": "geo_resolver", "job_id": job_id, "confidence": env.confidence})
    return state

def baseline_agent(state: BlackboardState) -> BlackboardState:
    job_id = state["job_id"]
    region_id = state["region_id"]
    scenario_id = state["scenario_id"]
    scenario = state["scenario"]

    geo = state["envelopes"]["geo"]
    entities = geo["artifacts"]["entities_raw"]

    # MVP：无计量数据时，按企业数+行业粗略估算
    # 真实实现：优先用计量数据，其次统计，再次模板/代理变量
    proxy_ratio = 0.7  # 大部分来自 proxy
    electricity_kwh_y = 120_000_000  # 120 GWh/y
    gas_nm3_y = 35_000_000          # 3500 万方/年

    # 排放因子（stub）：真实实现必须来自指标层/数据层版本化库
    grid_ef_tco2_per_kwh = 0.00055   # 0.55 t/MWh => 0.00055 t/kWh
    gas_ef_tco2_per_nm3 = 0.0021

    s2 = electricity_kwh_y * grid_ef_tco2_per_kwh
    s1 = gas_nm3_y * gas_ef_tco2_per_nm3
    total = s1 + s2

    data_completeness = geo["metrics"]["data_completeness_score"]
    conf = calc_confidence(data_completeness=data_completeness, proxy_ratio=proxy_ratio)

    env = ResultEnvelope(
        result_id=new_id(),
        scenario_id=scenario_id,
        region_id=region_id,
        stage="baseline",
        metrics={
            "baseline_electricity_kwh_y": electricity_kwh_y,
            "baseline_gas_nm3_y": gas_nm3_y,
            "S1_tco2e_y": round(s1, 2),
            "S2_tco2e_y": round(s2, 2),
            "total_tco2e_y": round(total, 2),
            "uncertainty_pct": 0.35,
            "ghg_boundary": scenario.ghg_boundary,
            "grid_ef_version": scenario.grid_ef_version,
            "fuel_ef_version": scenario.fuel_ef_version,
        },
        artifacts={
            "energy_balance": {
                "electricity_kwh_y": electricity_kwh_y,
                "gas_nm3_y": gas_nm3_y,
                "method": "proxy_by_industry_and_entity_count",
                "entities_used": len(entities),
            },
            "top_emitters": [{"type": "gas", "share": 0.55}, {"type": "electricity", "share": 0.45}],
        },
        assumptions=[
            AssumptionItem(name="proxy_ratio", value=proxy_ratio, unit=None, rationale="缺少园区计量曲线，使用行业模板与企业数估算").model_dump(),
            AssumptionItem(name="grid_ef_tco2_per_kwh", value=grid_ef_tco2_per_kwh, unit="tCO2/kWh", rationale="MVP占位：需指标层确认版本与地区").model_dump(),
        ],
        evidence=[
            EvidenceItem(type="table", id="industry_template@0.1", ts=now_ts(), version="0.1").model_dump(),
        ],
        confidence=conf,
        data_gaps=[
            DataGap(missing="园区电/气真实计量（小时/日/月）", impact="负荷画像、削峰填谷、8760仿真", severity="high", workaround="先输出年量与不确定性").model_dump(),
            DataGap(missing="电网排放因子（地区/时段）精确版本", impact="S2核算与绿电措施收益", severity="high").model_dump(),
        ],
        reproducibility=Reproducibility(model_version="baseline@0.1.0", param_version="baseline_params@0.1.0").model_dump(),
        human_checkpoints=[],
    )

    if env.confidence < 0.7 or env.metrics["uncertainty_pct"] > 0.3:
        env.human_checkpoints.append(
            HumanCheckpoint(
                checkpoint="baseline.review",
                question="请确认基线年用电/年用气数量级、排放因子版本与口径（S1/S2边界）是否正确；可修改关键 assumptions。",
                editable_fields=[
                    "metrics.baseline_electricity_kwh_y",
                    "metrics.baseline_gas_nm3_y",
                    "metrics.grid_ef_version",
                    "metrics.fuel_ef_version",
                    "assumptions",
                ],
                trigger_reason=f"confidence={env.confidence:.2f}, uncertainty_pct={env.metrics['uncertainty_pct']:.2f}",
            ).model_dump()
        )

    state["envelopes"]["baseline"] = env.model_dump()
    state.setdefault("logs", []).append({"ts": now_ts(), "node": "baseline", "job_id": job_id, "confidence": env.confidence})
    return state

def measure_screener_agent(state: BlackboardState) -> BlackboardState:
    job_id = state["job_id"]
    region_id = state["region_id"]
    scenario_id = state["scenario_id"]

    baseline = state["envelopes"]["baseline"]["metrics"]

    # MVP 措施库（占位）：真实来自“技术措施库”与参数版本化 
    measure_library = [
        {"id": "PV_ROOF", "name": "屋顶光伏", "requires": ["roof_area_m2"], "capex_y_per_kw": 3200, "life_y": 25},
        {"id": "BESS", "name": "储能削峰填谷", "requires": ["tou_tariff"], "capex_y_per_kwh": 900, "life_y": 10},
        {"id": "HP_STEAM", "name": "热泵替代低品位蒸汽/热水", "requires": ["steam_grade"], "capex_y": 30_000_000, "life_y": 15},
        {"id": "WHR", "name": "余热回收", "requires": ["waste_heat_profile"], "capex_y": 20_000_000, "life_y": 12},
    ]

    # 规则筛选：缺关键数据 -> 仍可入候选，但标 data_gap + 适用性降低
    candidates = []
    required_data = set()
    for m in measure_library:
        missing = [r for r in m["requires"]]
        score = 0.75 - 0.15 * len(missing)  # 很粗糙：缺数据就降分
        candidates.append({
            "id": m["id"],
            "name": m["name"],
            "applicability_score": max(0.1, score),
            "missing_inputs": missing,
            "expected_impact_range": {"co2_reduction_pct": [0.02, 0.10]},  # 占位：由工程模型替换
        })
        for r in missing:
            required_data.add(r)

    avg_score = sum(c["applicability_score"] for c in candidates) / max(1, len(candidates))

    env = ResultEnvelope(
        result_id=new_id(),
        scenario_id=scenario_id,
        region_id=region_id,
        stage="measures",
        metrics={
            "candidate_count": len(candidates),
            "avg_applicability_score": round(avg_score, 3),
        },
        artifacts={
            "candidates": sorted(candidates, key=lambda x: x["applicability_score"], reverse=True),
            "required_data_for_top10": sorted(list(required_data)),
        },
        assumptions=[
            AssumptionItem(name="screening_rule", value="score=0.75-0.15*missing_inputs", rationale="MVP规则；后续替换为约束评分/模型").model_dump()
        ],
        evidence=[
            EvidenceItem(type="table", id="measure_library@mvp", ts=now_ts(), version="0.1").model_dump(),
        ],
        confidence=0.72,
        data_gaps=[
            DataGap(missing="roof_area_m2", impact="屋顶光伏装机与发电量", severity="high").model_dump(),
            DataGap(missing="tou_tariff", impact="储能收益测算", severity="high").model_dump(),
            DataGap(missing="waste_heat_profile", impact="余热回收可行性与规模", severity="medium").model_dump(),
        ],
        reproducibility=Reproducibility(model_version="screener@0.1.0", param_version="screener_params@0.1.0").model_dump(),
        human_checkpoints=[],
    )

    if env.metrics["avg_applicability_score"] < 0.7:
        env.human_checkpoints.append(
            HumanCheckpoint(
                checkpoint="measures.review",
                question="请确认候选措施是否符合现场约束（屋顶/蒸汽等级/余热等）；可启用/禁用措施或调整评分规则。",
                editable_fields=["artifacts.candidates", "assumptions"],
                trigger_reason=f"avg_applicability_score={env.metrics['avg_applicability_score']}",
            ).model_dump()
        )

    state["envelopes"]["measures"] = env.model_dump()
    state.setdefault("logs", []).append({"ts": now_ts(), "node": "measure_screener", "job_id": job_id, "confidence": env.confidence})
    return state

def finance_integrator_agent(state: BlackboardState) -> BlackboardState:
    job_id = state["job_id"]
    region_id = state["region_id"]
    scenario_id = state["scenario_id"]
    scenario = state["scenario"]

    baseline = state["envelopes"]["baseline"]["metrics"]
    candidates = state["envelopes"]["measures"]["artifacts"]["candidates"]

    # MVP：选 Top2 措施做组合
    selected = candidates[:2]

    # 极简财务：capex + 年度节省（按基线电费的一个比例）- 运维
    baseline_ele_cost = baseline["baseline_electricity_kwh_y"] * scenario.electricity_price_y_per_kwh

    measure_cashflows = []
    total_capex = 0.0
    total_annual_net = 0.0

    for m in selected:
        # 占位：用 co2_reduction_pct 映射节省比例（非常粗糙，后续替换）
        saving_ratio = float(m["expected_impact_range"]["co2_reduction_pct"][0])  # 取保守端
        annual_saving = baseline_ele_cost * saving_ratio
        capex = 25_000_000 if m["id"] == "PV_ROOF" else 12_000_000  # 占位
        opex = 0.02 * capex
        annual_net = annual_saving - opex

        cashflows = [-capex] + [annual_net] * scenario.horizon_years
        m_npv = npv(scenario.wacc, cashflows)
        pb = simple_payback(capex, annual_net)

        measure_cashflows.append({
            "id": m["id"],
            "name": m["name"],
            "capex_y": capex,
            "opex_y": opex,
            "annual_saving_y": annual_saving,
            "annual_net_y": annual_net,
            "npv_y": m_npv,
            "payback_y": pb,
        })

        total_capex += capex
        total_annual_net += annual_net

    portfolio_cashflows = [-total_capex] + [total_annual_net] * scenario.horizon_years
    portfolio_npv = npv(scenario.wacc, portfolio_cashflows)
    portfolio_pb = simple_payback(total_capex, total_annual_net)

    env = ResultEnvelope(
        result_id=new_id(),
        scenario_id=scenario_id,
        region_id=region_id,
        stage="finance",
        metrics={
            "portfolio_capex": round(total_capex, 2),
            "portfolio_annual_net": round(total_annual_net, 2),
            "portfolio_npv": round(portfolio_npv, 2),
            "portfolio_payback_y": None if portfolio_pb is None else round(portfolio_pb, 2),
        },
        artifacts={
            "portfolio_selected": selected,
            "measure_cashflows": measure_cashflows,
            "scenario_params_used": scenario.model_dump(),
        },
        assumptions=[
            AssumptionItem(name="annual_saving_proxy", value="baseline_ele_cost * saving_ratio", rationale="MVP占位：需工程模型给出节能/发电量").model_dump(),
        ],
        evidence=[
            EvidenceItem(type="table", id="price_params@scenario", ts=now_ts(), version="0.1").model_dump(),
        ],
        confidence=0.70,
        data_gaps=[
            DataGap(missing="分时电价/需量电价", impact="储能收益、负荷策略", severity="high").model_dump(),
            DataGap(missing="光伏可装机容量与发电量模型", impact="光伏收益与减排", severity="high").model_dump(),
        ],
        reproducibility=Reproducibility(model_version="finance@0.1.0", param_version="finance_params@0.1.0").model_dump(),
        human_checkpoints=[],
    )

    if env.confidence < 0.75:
        env.human_checkpoints.append(
            HumanCheckpoint(
                checkpoint="finance.review",
                question="请确认电价/气价/碳价/WACC/措施CAPEX数量级是否合理；可修正 scenario_params 或 capex/opex 假设。",
                editable_fields=["artifacts.scenario_params_used", "artifacts.measure_cashflows", "assumptions"],
                trigger_reason=f"confidence={env.confidence:.2f} < 0.75",
            ).model_dump()
        )

    state["envelopes"]["finance"] = env.model_dump()
    state.setdefault("logs", []).append({"ts": now_ts(), "node": "finance", "job_id": job_id, "confidence": env.confidence})
    return state

def report_orchestrator_agent(state: BlackboardState) -> BlackboardState:
    job_id = state["job_id"]
    region_id = state["region_id"]
    scenario_id = state["scenario_id"]

    geo = state["envelopes"]["geo"]
    baseline = state["envelopes"]["baseline"]
    measures = state["envelopes"]["measures"]
    finance = state["envelopes"]["finance"]

    md = f"""# 园区低碳方案报告（MVP）

## 1. 选区与数据说明
- 面积：{geo['metrics']['area_km2']} km²
- 行政区：{geo['metrics']['admin_codes']}
- 数据完备度：{geo['metrics']['data_completeness_score']}

## 2. 基线核算（{baseline['metrics']['ghg_boundary']}）
- 年用电：{baseline['metrics']['baseline_electricity_kwh_y']:,} kWh
- 年用气：{baseline['metrics']['baseline_gas_nm3_y']:,} Nm³
- S1：{baseline['metrics']['S1_tco2e_y']:,} tCO₂e
- S2：{baseline['metrics']['S2_tco2e_y']:,} tCO₂e
- 合计：{baseline['metrics']['total_tco2e_y']:,} tCO₂e
- 不确定性：{baseline['metrics']['uncertainty_pct']*100:.0f}%

## 3. 候选措施（Top）
候选数：{measures['metrics']['candidate_count']}；平均适用性：{measures['metrics']['avg_applicability_score']}

- Top 1：{measures['artifacts']['candidates'][0]['name']}（缺口：{measures['artifacts']['candidates'][0]['missing_inputs']}）
- Top 2：{measures['artifacts']['candidates'][1]['name']}（缺口：{measures['artifacts']['candidates'][1]['missing_inputs']}）

## 4. 经济性（组合）
- CAPEX：{finance['metrics']['portfolio_capex']:,} 元
- 年净收益（proxy）：{finance['metrics']['portfolio_annual_net']:,} 元/年
- NPV：{finance['metrics']['portfolio_npv']:,} 元
- 回收期：{finance['metrics']['portfolio_payback_y']} 年

## 5. 数据缺口与下一步补数
- {baseline['data_gaps'][0]['missing']}（影响：{baseline['data_gaps'][0]['impact']}）
- {measures['data_gaps'][0]['missing']}（影响：{measures['data_gaps'][0]['impact']}）
"""

    env = ResultEnvelope(
        result_id=new_id(),
        scenario_id=scenario_id,
        region_id=region_id,
        stage="report",
        metrics={"report_pages_est": 6},
        artifacts={
            "report_markdown": md,
            "appendix_params_table": {
                "scenario": state["scenario"].model_dump(),
                "versions": {
                    "geo": geo["reproducibility"]["model_version"],
                    "baseline": baseline["reproducibility"]["model_version"],
                    "measures": measures["reproducibility"]["model_version"],
                    "finance": finance["reproducibility"]["model_version"],
                }
            },
            "appendix_citations": {
                "evidence_geo": geo["evidence"],
                "evidence_baseline": baseline["evidence"],
                "evidence_measures": measures["evidence"],
                "evidence_finance": finance["evidence"],
            }
        },
        assumptions=[],
        evidence=[],
        confidence=min(geo["confidence"], baseline["confidence"], measures["confidence"], finance["confidence"]),
        data_gaps=(geo["data_gaps"] + baseline["data_gaps"] + measures["data_gaps"] + finance["data_gaps"]),
        reproducibility=Reproducibility(model_version="report@0.1.0", param_version="report_params@0.1.0").model_dump(),
        human_checkpoints=[],
    )

    state["envelopes"]["report"] = env.model_dump()
    state.setdefault("logs", []).append({"ts": now_ts(), "node": "report", "job_id": job_id, "confidence": env.confidence})
    return state

# ====== 6) LangGraph 编排（MVP直线） ======
# 注意：不同版本 langgraph import 路径可能略有差异；你落地时按当前版本微调即可。

def build_graph():
    from langgraph.graph import StateGraph, END

    graph = StateGraph(BlackboardState)
    graph.add_node("geo_resolver", geo_resolver_agent)
    graph.add_node("baseline", baseline_agent)
    graph.add_node("measure_screener", measure_screener_agent)
    graph.add_node("finance", finance_integrator_agent)
    graph.add_node("report", report_orchestrator_agent)

    graph.set_entry_point("geo_resolver")
    graph.add_edge("geo_resolver", "baseline")
    graph.add_edge("baseline", "measure_screener")
    graph.add_edge("measure_screener", "finance")
    graph.add_edge("finance", "report")
    graph.add_edge("report", END)

    return graph.compile()

def run_mvp():
    app = build_graph()
    init_state: BlackboardState = {
        "job_id": new_id(),
        "scenario_id": new_id(),
        "region_id": new_id(),
        "selection": GeoSelection(type="polygon", geometry={"type": "Polygon", "coordinates": [[[120.0,30.0],[120.2,30.0],[120.2,30.2],[120.0,30.2],[120.0,30.0]]]}),
        "scenario": ScenarioParams(),
        "envelopes": {},
        "review_queue": [],
        "logs": [],
    }
    final_state = app.invoke(init_state)
    return final_state

if __name__ == "__main__":
    s = run_mvp()
    print(s["envelopes"]["report"]["artifacts"]["report_markdown"])
```

---

## 7) 中间结果样例（你下周 PPT/演示可直接贴）

下面给一个“流水线跑完后的 envelopes 摘要样例”（已对齐你文件的共享黑板字段精神）。

### 7.1 Geo（选区解析）输出样例（节选）
```json
{
  "stage": "geo",
  "metrics": {
    "area_km2": 3.4,
    "admin_codes": {"province":"XX","city":"YY","district":"ZZ"},
    "entity_count_est": 3,
    "data_completeness_score": 0.55
  },
  "artifacts": {
    "entities_raw": [
      {"name":"A化工","industry_code":"C26","confidence":0.7,"source":"poi"},
      {"name":"B材料","industry_code":"C30","confidence":0.6,"source":"poi"},
      {"name":"C制造","industry_code":null,"confidence":0.5,"source":"poi"}
    ]
  },
  "data_gaps": [
    {"missing":"园区名录/企业统一社会信用代码","impact":"企业去重、行业细分、产能proxy","severity":"medium"},
    {"missing":"园区电价规则/分时","impact":"经济性、电力措施收益","severity":"high"}
  ],
  "human_checkpoints": [
    {
      "checkpoint":"geo.review",
      "status":"pending",
      "editable_fields":["artifacts.region_boundary","artifacts.entities_raw","metrics.admin_codes"],
      "trigger_reason":"confidence=0.64 < 0.70"
    }
  ]
}
```

### 7.2 Baseline（基线）输出样例（节选）
```json
{
  "stage": "baseline",
  "metrics": {
    "baseline_electricity_kwh_y": 120000000,
    "baseline_gas_nm3_y": 35000000,
    "S1_tco2e_y": 73500.0,
    "S2_tco2e_y": 66000.0,
    "total_tco2e_y": 139500.0,
    "uncertainty_pct": 0.35,
    "ghg_boundary": "S1S2",
    "grid_ef_version": "CN-grid-2024-v1",
    "fuel_ef_version": "IPCC-2006-default-v1"
  },
  "assumptions": [
    {"name":"proxy_ratio","value":0.7,"rationale":"缺少园区计量曲线，使用行业模板与企业数估算"},
    {"name":"grid_ef_tco2_per_kwh","value":0.00055,"unit":"tCO2/kWh"}
  ],
  "data_gaps": [
    {"missing":"园区电/气真实计量（小时/日/月）","impact":"负荷画像、削峰填谷、8760仿真","severity":"high"},
    {"missing":"电网排放因子（地区/时段）精确版本","impact":"S2核算与绿电措施收益","severity":"high"}
  ]
}
```

### 7.3 Measures（措施筛选）输出样例（节选）
```json
{
  "stage": "measures",
  "artifacts": {
    "candidates": [
      {"id":"PV_ROOF","name":"屋顶光伏","applicability_score":0.6,"missing_inputs":["roof_area_m2"]},
      {"id":"BESS","name":"储能削峰填谷","applicability_score":0.6,"missing_inputs":["tou_tariff"]}
    ],
    "required_data_for_top10": ["roof_area_m2", "tou_tariff", "steam_grade", "waste_heat_profile"]
  }
}
```

### 7.4 Finance（经济性）输出样例（节选）
```json
{
  "stage": "finance",
  "metrics": {
    "portfolio_capex": 37000000.0,
    "portfolio_annual_net": 1500000.0,
    "portfolio_npv": 4200000.0,
    "portfolio_payback_y": 24.67
  },
  "data_gaps": [
    {"missing":"分时电价/需量电价","impact":"储能收益、负荷策略","severity":"high"},
    {"missing":"光伏可装机容量与发电量模型","impact":"光伏收益与减排","severity":"high"}
  ]
}
```

### 7.5 Report（报告）输出样例（节选）
- `artifacts.report_markdown`：可直接导出
- `appendix_params_table`：参数表（支持你们要求的“附录强制参数表与引用”）

---

## 8) 我需要分析层/架构层提供什么（你可以直接复制粘贴发群里）

下面这些“要人给输入”的点，都是为了让你在 LangGraph 里把 Agent 从 stub 换成真实工具调用时，不会卡住。

### 8.1 发给分析层（知识图谱/政策文件）的消息
> （你导师要求“分析点—政策条款—适用对象—证据引用”的知识图谱框架与政策原文整理，这会直接喂给 Policy&Compliance Agent 与报告引用）

- **@冯德帆（知识图谱）**  
  我这边多智能体链路要接一个 `Policy&Compliance(RAG)` 节点：  
  1) 请给我 **KG 的最小 Schema**：`analysis_point_id → clause_id → applicable_object → evidence_id`  
  2) 以及 **查询接口定义**（哪怕先是本地 JSON）：输入 `region_admin_codes + industry_codes + measure_ids`，输出 `matched_clauses[]`（含引用编号）。  
  3) 每条返回需要带：`clause_id / doc_id / excerpt / effective_date / scope / citation_no`，用于报告可追溯。

- **@张子辰（政策文件）**  
  为了让报告 Agent 能“自动引用”，请你把政策文件整理产出一个结构化清单（CSV/JSON 都行）：  
  - `doc_id, title, source_url/出处, 生效日期, 适用范围, 条款编号, 条款摘录(<=200字), citation_no`  
  - 并按“分析点”做一个映射表：`analysis_point_id -> [citation_no...]`  
  这样我就能在 report_orchestrator 里稳定插引用，不靠模型瞎编。

### 8.2 发给架构层（UI/接口）的消息
你文件里已经列了 MVP 需要冻结的接口（/regions/analyze、/jobs/{job_id}、/results/{scenario_id}、/reports/export、/data/lineage…），多智能体层实现会直接依赖 job 与中间结果快照。

- **@可（接口）**  
  我这边 LangGraph 会按“每个 Agent 输出一个 ResultEnvelope”落库/回传。为保证下周 demo 可观测：  
  1) 请定义 `GET /jobs/{job_id}` 的返回结构里，至少包含：  
     - `current_stage`、`stage_status[]`、`logs[]`、`latest_envelopes{stage: envelope_summary}`  
  2) 请预留一个 **人工校验回写接口**（即使下周先不做 UI 也行）：  
     - `POST /jobs/{job_id}/reviews/{checkpoint_id}` body: `{status, patch}`  
  3) `GET /data/lineage` 需要能按 `result_id + metric_key` 追溯到 `assumptions/evidence/reproducibility`（我会按 envelope 字段提供）。  

- **@yang（UI）**  
  我需要你下周 demo 的 MVP 页面至少能：  
  1) 输出 `selection`（polygon/admin_code/park_id）给后端  
  2) 展示 `review_queue`（哪些节点需要人工确认）  
  3) 展示结果对比时，优先读 `/results/{scenario_id}` 返回的 `metrics + top_measures + finance_summary`  

- **@_水桦_（整体）**  
  多智能体层会把每次运行的 `输入快照/参数版本/模型版本/中间结果` 都写出来（对齐你们“可复算、可审计”要求）。  
  我需要你帮忙拍板：  
  - 哪些字段算敏感数据（企业名录/计量曲线）要做权限隔离？  
  - job 日志与 evidence 文档的审计保留周期？

---

## 9) 你接下来可以怎么用（给你一个落地顺序）

为了你“下周能讲、能演示、能跑通”，我建议你按这个顺序做：

1) **先实现 schema + LangGraph 直线链路**（用 stub 数据也行）  
2) 把每个节点输出落成 `ResultEnvelope` 并写入 `/jobs/{id}` 的快照  
3) 把 `human_checkpoints` 和 `data_gaps` 在 UI 上展示出来（这就是“挑战与计划”的最好素材）  
4) 再逐个把 stub 工具替换成真实数据调用（PostGIS/企业名录/电价/排放因子/措施库）

---

如果你愿意，我也可以在你现有 repo 结构（你用 openai + langgraph）基础上，把上面这套骨架按模块拆好（`schemas.py / graph.py / agents/`），并补上 **“API 契约对齐（/regions/analyze → job_id → /jobs/{id}）”的请求/响应样例**，方便你直接和 @可 对接。